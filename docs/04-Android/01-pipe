# Pipe

This module contains:

- examples of queries allowing to request data from our GraphQL schema
- examples of queries with pagination allowing to request lists of data from our GraphQL schema
- examples of mutations allowing to change data on our GraphQL schema
- all classes relate to [Apollo library](https://www.apollographql.com/docs/android/)

## What is Pipe?

Pipe is the public API enabling developers to build a user experience on Deezer.
The public URL to reach it is **https://pipe.deezer.com/api**.

But before you can query it, you will need to have an authentication service token (JWT) that has to be provided by your app.
**Deezer SDK** for Android provides a way to retrieve this token.

# GraphQL

Pipe is based on [GraphQL](https://graphql.org), an API framework that will let you create your own requests with type safety.

You can find the graph and a playground of Pipe API [here](https://plumbers.deezer.com)

# Downloading a schema

Apollo Android requires a GraphQL schema file as input to the code generation process.
A schema file is a JSON file that contains the results of an introspection query. Conventionally this file is called schema.json, and you store it next to the .graphql files in your target.

You can use the [Apollo Task Gradle](https://www.apollographql.com/docs/android/tutorial/02-add-the-graphql-schema/) to download a GraphQL schema by sending an introspection query to the server.

By convenience a default preconfigured Gradle task called **downloadPipeApolloSchema** is provided to fetch last version of GraphQL schema for Pipe API.
You can call it as follows:

```sh
./gradlew :deezer-api:downloadPipeApolloSchema
```

# Letâ€™s do our first query to Pipe

Queries are represented as instances of generated classes conforming to the GraphQLQuery protocol. Constructor arguments can be used to define query variables if needed.

You pass a query object to **ApolloClient.query(<your query>)** to send the query to the server, execute it, and receive typed results.

What if we ask Deezer some info, letâ€™s sayâ€¦ about a mythic album of Daft Punk. This album has an ID of 302127.

First step, navigate to **[Apollo queries directory](src/main/graphql/com.deezer.api.graphql/query/)**.

In Pipe we will use the query album to get this album by ID, you can define a query called **_MyFirstQuery_** in **AlbumQuery.graphql**:

```sh
query MyFirstQuery($albumId: String!) {
    album(albumId: $albumId) {
    id
    displayTitle
    releaseDate
    label
  }
}
```

The next step is to build your app. Apollo android plugin defines a task **generateApolloSources** which will generate the models. You don't need to run it manually ðŸ™‚.

You can now update the code to use your new query:

In **ApolloAlbumRepository.kt** :

```kotlin
    override fun fetchMyFirstAlbumQuery(albumId: String, listener: AlbumRepository.AlbumRepositoryListener) {
        apolloClient
            .query(MyFirstQuery(albumId))
            .enqueue(
                // Use an ErrorProcessingApolloCallback (an implementation of ApolloCall.Callback) to avoid manual error parsing
                ErrorProcessingApolloCallback(
                    repositoryName = javaClass.simpleName,
                    dataExtractor = { data: MyFirstQuery.Data? -> data?.album },
                    transformer = transformer, // you need to provide a transformer as Apollo models are translated to local models for needs of layer segregation
                    apiErrorParser = apiErrorParser, // provide a parser which allows interpreting common Pipe API errors
                    callback = listener
                )
            )
    }
```

Alternatively you can also create your own _ApolloCall.Callback_:

```kotlin
    override fun fetchMyFirstAlbumQuery(albumId: String, listener: AlbumRepository.AlbumRepositoryListener) {
        apolloClient
            .query(MyFirstQuery(albumId))
            .enqueue(object :ApolloCall.Callback<MyFirstQuery.Data>() {
                override fun onFailure(e: ApolloException) {
                    Log.e(LOG_TAG, "onFailure when fetching data in ${javaClass.name} : ${e.message}")
                }
                override fun onResponse(response: Response<MyFirstQuery.Data>) {
                    // you need to use a transformer as Apollo models are translated to local models for needs of layer segregation
                    val result = transformer.transform(response.data?.album)
                    listener.onFetched(result)
                }
            })
    }
```

In **AlbumViewModel.kt** :

```kotlin
    fun fetchMyFirstQuery(albumId: String) {
        viewModelScope.launch {
            val album = suspendCancellableCoroutine<Album> {
                albumRepository.fetchMyFirstQuery(albumId, object : DeezerRepositoryCallback {
                    override fun onFetched(data: Album) {
                        it.resume(data)
                    }
                })
            }
            _album.postValue(album)
        }
    }
```

**Where to find more information?**

[Apollo Android](https://www.apollographql.com/docs/android/)
